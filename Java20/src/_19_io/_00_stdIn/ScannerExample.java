package _19_io._00_stdIn;

import java.util.Scanner;

public class ScannerExample {

	public static void main(String[] args) {
		/*
		 * http://mastefanov.com/wp-content/uploads/2014/02/programmingJava.
		 * lec3_.4Scanner.pdf
		 */
		
		double doubleFoo;
		int integerBar;
		float floatQuiz;
		long longBaz;
		String token;
		String line;
		
		try (Scanner stdInScanner = new Scanner(System.in)) {
			doubleFoo = stdInScanner.nextDouble();
			integerBar = stdInScanner.nextInt();
			floatQuiz = stdInScanner.nextFloat();
			longBaz = stdInScanner.nextLong();
			token = stdInScanner.next();
			line = stdInScanner.nextLine();
		}
		
		System.out.printf("double=%f\nint=%d\nfloat=%f\nlong=%d\ntoken=%s\nline=%s\n", doubleFoo, integerBar, floatQuiz,
				longBaz, token, line);
		System.out.println("over");
	}

}

/*
 * Работа программы: 1,1 2 3 4 5 double=1,100000 int=2 float=3,000000 long=4
 * token=5 line= over Более детально работу метода printf() мы рассмотрим в
 * следующем параграфе, в общем смысл таков – первым параметром задается
 * форматирующая строка, содержащая специальные группы символов (начинающиеся со
 * знака %), которые в результате заменяются соответствующим значением из списка
 * параметров. Пользовательский ввод обозначен зеленым цветом, вывод программы –
 * черным. В случае с вещественными и целыми числами все выглядит логично.
 * Пользователь вводит число, после чего нажимает enter. Введённое им значение
 * попадает в поток System.in и считывается сканнером. В каждой строке
 * присутствует только одно число. При этом с помощью метода nextFloat() (и
 * nextDouble()) мы можете считать не только вещественные числа, но и целые (но
 * в результате они все равно будут представлены как вещественные). Таким
 * образом, мы успешно считываем 4 числа и записываем их в переменные,
 * соответственно doubleFoo, integerBar, floatQuiz, longBaz. Однако дальше
 * проявляется особенность метода nextLine(). После методов, считывающих числа,
 * идут вызовы next() и nextLine(): String token = stdInScanner.next(); String
 * line = stdInScanner.nextLine(); Казалось бы, после ввода пользователем числа
 * 5 (которое логично считывается методом next() и записывается в переменную
 * token), программа должна ожидать ввода строки – но этого не происходит, она
 * завершает свою работу, а переменная line в итоге не содержит никакого
 * значения. Давайте рассмотрим, что попадает в поток, когда пользователь вводит
 * 5 и нажимает enter. Во входном потоке оказывается последовательность бит,
 * которая соответствует символу ‘5’ и символу «конец строки». Конец строки – по
 * умолчанию является разделителем токенов, поэтому все, что было до него, было
 * считано методом next(), и маркер, который показывает текущее положение в
 * потоке, устанавливается после 5, но перед «концом строки». Затем вызывается
 * метод nextLine(), который успешно обнаруживает оставшуюся группу символов,
 * соответствующих «концу строки» и успешно считывает его. Но поскольку никаких
 * символов между маркером и концом строки нет, то в буфер ничего не заносится,
 * и следовательно, в результате методом ничего не возвращается и в переменную
 * line ничего не записывается. Пара слов, относительно группы символов «конец
 * строки». По стандарту, любое совместимое с Юникодом приложение должно
 * воспринимать как перевод строки каждый из нижеследующих символов: LF
 * (U+000A): англ. line feed — подача строки; CR (U+000D): англ. carriage return
 * — возврат каретки; CR + LF – рассматривается как один перевод строки, а не 2
 * NEL (U+0085): англ. next line — переход на следующую строку; LS (U+2028):
 * англ. line separator — разделитель строк; PS (U+2029): англ. paragraph
 * separator — разделитель абзацев. В стандартных текстовых файлах, использующих
 * кодировку ASCII в зависимости от операционной системы, в качестве разделителя
 * строк могут использоваться сомволы: LF – Unix, FreeBSD, MacOS… CR – (старые
 * версии MacOS) CR + LF – MSDOS, Windows. Рассмотрим еще один пример
 * пользовательского ввода предыдущей программы: 1,1 2 3 4 5 678 9
 * double=1,100000 int=2 float=3,000000 long=4 token=5 line= 678 9 over
 * По-прежнему, символы, вводимые пользователем помечены зеленым цветом. Этот
 * пример показывает несколько нюансов: 1) По-умолчанию, «лишние» пробелы при
 * поиске токенов во входном потоке с помощью метода класса Scanner
 * игнорируются. 2) Если в предыдущем случае все методы считывания блокировали
 * работу программы, пока пользователь не введет что-либо, то сейчас блокировка
 * осуществляется только методом nextDouble() и next(). 3) После считывания
 * какого-либо токена, остальные биты из потока не удаляются и могут быть
 * считаны последующими вызовами методов чтения. В данном случае, метод
 * nextDouble() блокирует выполнение программы. После того как пользователь ввел
 * строку «1,1 2 3 4» метод считал токен 1,1 и поместил маркер чтения сразу
 * после него. Следующий метод считал все пробелы, затем 2 и поместил маркер
 * сразу за символом 2. Затем в программе подряд вызывается еще 2 метода,
 * которые считывают, соответственно 3 и 4 не блокируя работу программы в
 * ожидании ввода. 4) Последняя строка показывает, что маркер чтения
 * устанавливается методами nextX() сразу после считанного токена (и следующие
 * за ним разделители считываются уже следующим вызовом nextX()). next() считал
 * 5, а nextLine() вернул строку из символов, между 5 и концом строки (включая
 * пробел между 5 и 678).
 */
